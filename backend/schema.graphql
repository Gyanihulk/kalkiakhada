# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type AmityTokenResult {
  token: String
  user: String
}

type Query {
  userAmityToken: AmityTokenResult
  users(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  assets(
    where: AssetWhereInput! = {}
    orderBy: [AssetOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Asset!]
  asset(where: AssetWhereUniqueInput!): Asset
  assetsCount(where: AssetWhereInput! = {}): Int
  roles(
    where: RoleWhereInput! = {}
    orderBy: [RoleOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Role!]
  role(where: RoleWhereUniqueInput!): Role
  rolesCount(where: RoleWhereInput! = {}): Int
  categories(
    where: CategoryWhereInput! = {}
    orderBy: [CategoryOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Category!]
  category(where: CategoryWhereUniqueInput!): Category
  categoriesCount(where: CategoryWhereInput! = {}): Int
  collections(
    where: CollectionWhereInput! = {}
    orderBy: [CollectionOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Collection!]
  collection(where: CollectionWhereUniqueInput!): Collection
  collectionsCount(where: CollectionWhereInput! = {}): Int
  structures(
    where: StructureWhereInput! = {}
    orderBy: [StructureOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Structure!]
  structure(where: StructureWhereUniqueInput!): Structure
  structuresCount(where: StructureWhereInput! = {}): Int
  tags(
    where: TagWhereInput! = {}
    orderBy: [TagOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Tag!]
  tag(where: TagWhereUniqueInput!): Tag
  tagsCount(where: TagWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
  validateUserPasswordResetToken(
    email: String!
    token: String!
  ): ValidateUserPasswordResetTokenResult
}

type User {
  id: ID!
  name: String
  email: String
  password: PasswordState
  about: User_about_Document
  avatar: Asset
  contactNumber: String
  userType: UserUserTypeType
  role: Role
  asset: Asset
  passwordResetToken: PasswordState
  passwordResetIssuedAt: DateTime
  passwordResetRedeemedAt: DateTime
}

type PasswordState {
  isSet: Boolean!
}

type User_about_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

enum UserUserTypeType {
  trainer
  gymOwner
  trainee
}

scalar DateTime
  @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  avatar: AssetWhereInput
  contactNumber: StringFilter
  userType: UserUserTypeTypeNullableFilter
  role: RoleWhereInput
  asset: AssetWhereInput
  passwordResetToken: PasswordFilter
  passwordResetIssuedAt: DateTimeNullableFilter
  passwordResetRedeemedAt: DateTimeNullableFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input UserUserTypeTypeNullableFilter {
  equals: UserUserTypeType
  in: [UserUserTypeType!]
  notIn: [UserUserTypeType!]
  not: UserUserTypeTypeNullableFilter
}

input PasswordFilter {
  isSet: Boolean!
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
  contactNumber: OrderDirection
  userType: OrderDirection
  passwordResetIssuedAt: OrderDirection
  passwordResetRedeemedAt: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  about: JSON
  avatar: AssetRelateToOneForUpdateInput
  contactNumber: String
  userType: UserUserTypeType
  role: RoleRelateToOneForUpdateInput
  asset: AssetRelateToOneForUpdateInput
  passwordResetToken: String
  passwordResetIssuedAt: DateTime
  passwordResetRedeemedAt: DateTime
}

input AssetRelateToOneForUpdateInput {
  create: AssetCreateInput
  connect: AssetWhereUniqueInput
  disconnect: Boolean
}

input RoleRelateToOneForUpdateInput {
  create: RoleCreateInput
  connect: RoleWhereUniqueInput
  disconnect: Boolean
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  password: String
  about: JSON
  avatar: AssetRelateToOneForCreateInput
  contactNumber: String
  userType: UserUserTypeType
  role: RoleRelateToOneForCreateInput
  asset: AssetRelateToOneForCreateInput
  passwordResetToken: String
  passwordResetIssuedAt: DateTime
  passwordResetRedeemedAt: DateTime
}

input AssetRelateToOneForCreateInput {
  create: AssetCreateInput
  connect: AssetWhereUniqueInput
}

input RoleRelateToOneForCreateInput {
  create: RoleCreateInput
  connect: RoleWhereUniqueInput
}

type Asset {
  id: ID!
  file: FileFieldOutput
  folder: AssetFolderType
  altTitle: String
  caption: String
  status: AssetStatusType
  author: User
  tags(
    where: TagWhereInput! = {}
    orderBy: [TagOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Tag!]
  tagsCount(where: TagWhereInput! = {}): Int
  dateCreated: DateTime
  dateUpdated: DateTime
}

interface FileFieldOutput {
  filename: String!
  filesize: Int!
  ref: String!
  url: String!
}

enum AssetFolderType {
  active
  inactive
}

enum AssetStatusType {
  active
  inactive
}

input AssetWhereUniqueInput {
  id: ID
}

type LocalFileFieldOutput implements FileFieldOutput {
  filename: String!
  filesize: Int!
  ref: String!
  url: String!
}

type CloudFileFieldOutput implements FileFieldOutput {
  filename: String!
  filesize: Int!
  ref: String!
  url: String!
}

input AssetWhereInput {
  AND: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  NOT: [AssetWhereInput!]
  id: IDFilter
  folder: AssetFolderTypeNullableFilter
  altTitle: StringFilter
  caption: StringFilter
  status: AssetStatusTypeNullableFilter
  author: UserWhereInput
  tags: TagManyRelationFilter
  dateCreated: DateTimeNullableFilter
  dateUpdated: DateTimeNullableFilter
}

input AssetFolderTypeNullableFilter {
  equals: AssetFolderType
  in: [AssetFolderType!]
  notIn: [AssetFolderType!]
  not: AssetFolderTypeNullableFilter
}

input AssetStatusTypeNullableFilter {
  equals: AssetStatusType
  in: [AssetStatusType!]
  notIn: [AssetStatusType!]
  not: AssetStatusTypeNullableFilter
}

input TagManyRelationFilter {
  every: TagWhereInput
  some: TagWhereInput
  none: TagWhereInput
}

input AssetOrderByInput {
  id: OrderDirection
  folder: OrderDirection
  altTitle: OrderDirection
  caption: OrderDirection
  status: OrderDirection
  dateCreated: OrderDirection
  dateUpdated: OrderDirection
}

input AssetUpdateInput {
  file: FileFieldInput
  folder: AssetFolderType
  altTitle: String
  caption: String
  status: AssetStatusType
  author: UserRelateToOneForUpdateInput
  tags: TagRelateToManyForUpdateInput
  dateCreated: DateTime
  dateUpdated: DateTime
}

input FileFieldInput {
  upload: Upload
  ref: String
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input TagRelateToManyForUpdateInput {
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

input AssetUpdateArgs {
  where: AssetWhereUniqueInput!
  data: AssetUpdateInput!
}

input AssetCreateInput {
  file: FileFieldInput
  folder: AssetFolderType
  altTitle: String
  caption: String
  status: AssetStatusType
  author: UserRelateToOneForCreateInput
  tags: TagRelateToManyForCreateInput
  dateCreated: DateTime
  dateUpdated: DateTime
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input TagRelateToManyForCreateInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type Role {
  id: ID!
  name: String
  handle: String
  description: String
  permissions: Boolean
  dateCreated: DateTime
  dateUpdated: DateTime
  canSeeOtherUsers: Boolean
  canManageUsers: Boolean
  canManageRoles: Boolean
  canReadListing: Boolean
  canManageListing: Boolean
  canManageAnimal: Boolean
  canManageArticle: Boolean
  canManageEvent: Boolean
  canManagePage: Boolean
  canManageTrait: Boolean
  assignedTo(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  assignedToCount(where: UserWhereInput! = {}): Int
}

input RoleWhereUniqueInput {
  id: ID
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  id: IDFilter
  name: StringFilter
  handle: StringFilter
  description: StringFilter
  permissions: BooleanFilter
  dateCreated: DateTimeNullableFilter
  dateUpdated: DateTimeNullableFilter
  canSeeOtherUsers: BooleanFilter
  canManageUsers: BooleanFilter
  canManageRoles: BooleanFilter
  canReadListing: BooleanFilter
  canManageListing: BooleanFilter
  canManageAnimal: BooleanFilter
  canManageArticle: BooleanFilter
  canManageEvent: BooleanFilter
  canManagePage: BooleanFilter
  canManageTrait: BooleanFilter
  assignedTo: UserManyRelationFilter
}

input BooleanFilter {
  equals: Boolean
  not: BooleanFilter
}

input UserManyRelationFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input RoleOrderByInput {
  id: OrderDirection
  name: OrderDirection
  handle: OrderDirection
  description: OrderDirection
  permissions: OrderDirection
  dateCreated: OrderDirection
  dateUpdated: OrderDirection
  canSeeOtherUsers: OrderDirection
  canManageUsers: OrderDirection
  canManageRoles: OrderDirection
  canReadListing: OrderDirection
  canManageListing: OrderDirection
  canManageAnimal: OrderDirection
  canManageArticle: OrderDirection
  canManageEvent: OrderDirection
  canManagePage: OrderDirection
  canManageTrait: OrderDirection
}

input RoleUpdateInput {
  name: String
  handle: String
  description: String
  permissions: Boolean
  dateCreated: DateTime
  dateUpdated: DateTime
  canSeeOtherUsers: Boolean
  canManageUsers: Boolean
  canManageRoles: Boolean
  canReadListing: Boolean
  canManageListing: Boolean
  canManageAnimal: Boolean
  canManageArticle: Boolean
  canManageEvent: Boolean
  canManagePage: Boolean
  canManageTrait: Boolean
  assignedTo: UserRelateToManyForUpdateInput
}

input UserRelateToManyForUpdateInput {
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input RoleUpdateArgs {
  where: RoleWhereUniqueInput!
  data: RoleUpdateInput!
}

input RoleCreateInput {
  name: String
  handle: String
  description: String
  permissions: Boolean
  dateCreated: DateTime
  dateUpdated: DateTime
  canSeeOtherUsers: Boolean
  canManageUsers: Boolean
  canManageRoles: Boolean
  canReadListing: Boolean
  canManageListing: Boolean
  canManageAnimal: Boolean
  canManageArticle: Boolean
  canManageEvent: Boolean
  canManagePage: Boolean
  canManageTrait: Boolean
  assignedTo: UserRelateToManyForCreateInput
}

input UserRelateToManyForCreateInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

type Category {
  id: ID!
  title: String
  handle: String
  dateCreated: DateTime
  dateUpdated: DateTime
}

input CategoryWhereUniqueInput {
  id: ID
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  id: IDFilter
  title: StringFilter
  handle: StringFilter
  dateCreated: DateTimeNullableFilter
  dateUpdated: DateTimeNullableFilter
}

input CategoryOrderByInput {
  id: OrderDirection
  title: OrderDirection
  handle: OrderDirection
  dateCreated: OrderDirection
  dateUpdated: OrderDirection
}

input CategoryUpdateInput {
  title: String
  handle: String
  dateCreated: DateTime
  dateUpdated: DateTime
}

input CategoryUpdateArgs {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input CategoryCreateInput {
  title: String
  handle: String
  dateCreated: DateTime
  dateUpdated: DateTime
}

type Collection {
  id: ID!
  title: String
  handle: String
  author: User
  status: CollectionStatusType
  tags(
    where: TagWhereInput! = {}
    orderBy: [TagOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Tag!]
  tagsCount(where: TagWhereInput! = {}): Int
  dateCreated: DateTime
  dateUpdated: DateTime
}

enum CollectionStatusType {
  active
  inactive
}

input CollectionWhereUniqueInput {
  id: ID
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  NOT: [CollectionWhereInput!]
  id: IDFilter
  title: StringFilter
  handle: StringFilter
  author: UserWhereInput
  status: CollectionStatusTypeNullableFilter
  tags: TagManyRelationFilter
  dateCreated: DateTimeNullableFilter
  dateUpdated: DateTimeNullableFilter
}

input CollectionStatusTypeNullableFilter {
  equals: CollectionStatusType
  in: [CollectionStatusType!]
  notIn: [CollectionStatusType!]
  not: CollectionStatusTypeNullableFilter
}

input CollectionOrderByInput {
  id: OrderDirection
  title: OrderDirection
  handle: OrderDirection
  status: OrderDirection
  dateCreated: OrderDirection
  dateUpdated: OrderDirection
}

input CollectionUpdateInput {
  title: String
  handle: String
  author: UserRelateToOneForUpdateInput
  status: CollectionStatusType
  tags: TagRelateToManyForUpdateInput
  dateCreated: DateTime
  dateUpdated: DateTime
}

input CollectionUpdateArgs {
  where: CollectionWhereUniqueInput!
  data: CollectionUpdateInput!
}

input CollectionCreateInput {
  title: String
  handle: String
  author: UserRelateToOneForCreateInput
  status: CollectionStatusType
  tags: TagRelateToManyForCreateInput
  dateCreated: DateTime
  dateUpdated: DateTime
}

type Structure {
  id: ID!
  name: String
  handle: String
  structure: JSON
  dateCreated: DateTime
  dateUpdated: DateTime
}

input StructureWhereUniqueInput {
  id: ID
}

input StructureWhereInput {
  AND: [StructureWhereInput!]
  OR: [StructureWhereInput!]
  NOT: [StructureWhereInput!]
  id: IDFilter
  name: StringFilter
  handle: StringFilter
  dateCreated: DateTimeNullableFilter
  dateUpdated: DateTimeNullableFilter
}

input StructureOrderByInput {
  id: OrderDirection
  name: OrderDirection
  handle: OrderDirection
  dateCreated: OrderDirection
  dateUpdated: OrderDirection
}

input StructureUpdateInput {
  name: String
  handle: String
  structure: JSON
  dateCreated: DateTime
  dateUpdated: DateTime
}

input StructureUpdateArgs {
  where: StructureWhereUniqueInput!
  data: StructureUpdateInput!
}

input StructureCreateInput {
  name: String
  handle: String
  structure: JSON
  dateCreated: DateTime
  dateUpdated: DateTime
}

type Tag {
  id: ID!
  title: String
  handle: String
  tagType: Structure
  dateCreated: DateTime
  dateUpdated: DateTime
}

input TagWhereUniqueInput {
  id: ID
}

input TagWhereInput {
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
  id: IDFilter
  title: StringFilter
  handle: StringFilter
  tagType: StructureWhereInput
  dateCreated: DateTimeNullableFilter
  dateUpdated: DateTimeNullableFilter
}

input TagOrderByInput {
  id: OrderDirection
  title: OrderDirection
  handle: OrderDirection
  dateCreated: OrderDirection
  dateUpdated: OrderDirection
}

input TagUpdateInput {
  title: String
  handle: String
  tagType: StructureRelateToOneForUpdateInput
  dateCreated: DateTime
  dateUpdated: DateTime
}

input StructureRelateToOneForUpdateInput {
  create: StructureCreateInput
  connect: StructureWhereUniqueInput
  disconnect: Boolean
}

input TagUpdateArgs {
  where: TagWhereUniqueInput!
  data: TagUpdateInput!
}

input TagCreateInput {
  title: String
  handle: String
  tagType: StructureRelateToOneForCreateInput
  dateCreated: DateTime
  dateUpdated: DateTime
}

input StructureRelateToOneForCreateInput {
  create: StructureCreateInput
  connect: StructureWhereUniqueInput
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createAsset(data: AssetCreateInput!): Asset
  createAssets(data: [AssetCreateInput!]!): [Asset]
  updateAsset(where: AssetWhereUniqueInput!, data: AssetUpdateInput!): Asset
  updateAssets(data: [AssetUpdateArgs!]!): [Asset]
  deleteAsset(where: AssetWhereUniqueInput!): Asset
  deleteAssets(where: [AssetWhereUniqueInput!]!): [Asset]
  createRole(data: RoleCreateInput!): Role
  createRoles(data: [RoleCreateInput!]!): [Role]
  updateRole(where: RoleWhereUniqueInput!, data: RoleUpdateInput!): Role
  updateRoles(data: [RoleUpdateArgs!]!): [Role]
  deleteRole(where: RoleWhereUniqueInput!): Role
  deleteRoles(where: [RoleWhereUniqueInput!]!): [Role]
  createCategory(data: CategoryCreateInput!): Category
  createCategories(data: [CategoryCreateInput!]!): [Category]
  updateCategory(
    where: CategoryWhereUniqueInput!
    data: CategoryUpdateInput!
  ): Category
  updateCategories(data: [CategoryUpdateArgs!]!): [Category]
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteCategories(where: [CategoryWhereUniqueInput!]!): [Category]
  createCollection(data: CollectionCreateInput!): Collection
  createCollections(data: [CollectionCreateInput!]!): [Collection]
  updateCollection(
    where: CollectionWhereUniqueInput!
    data: CollectionUpdateInput!
  ): Collection
  updateCollections(data: [CollectionUpdateArgs!]!): [Collection]
  deleteCollection(where: CollectionWhereUniqueInput!): Collection
  deleteCollections(where: [CollectionWhereUniqueInput!]!): [Collection]
  createStructure(data: StructureCreateInput!): Structure
  createStructures(data: [StructureCreateInput!]!): [Structure]
  updateStructure(
    where: StructureWhereUniqueInput!
    data: StructureUpdateInput!
  ): Structure
  updateStructures(data: [StructureUpdateArgs!]!): [Structure]
  deleteStructure(where: StructureWhereUniqueInput!): Structure
  deleteStructures(where: [StructureWhereUniqueInput!]!): [Structure]
  createTag(data: TagCreateInput!): Tag
  createTags(data: [TagCreateInput!]!): [Tag]
  updateTag(where: TagWhereUniqueInput!, data: TagUpdateInput!): Tag
  updateTags(data: [TagUpdateArgs!]!): [Tag]
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteTags(where: [TagWhereUniqueInput!]!): [Tag]
  endSession: Boolean!
  authenticateUserWithPassword(
    email: String!
    password: String!
  ): UserAuthenticationWithPasswordResult
  createInitialUser(
    data: CreateInitialUserInput!
  ): UserAuthenticationWithPasswordSuccess!
  sendUserPasswordResetLink(email: String!): Boolean!
  redeemUserPasswordResetToken(
    email: String!
    token: String!
    password: String!
  ): RedeemUserPasswordResetTokenResult
}

union UserAuthenticationWithPasswordResult =
    UserAuthenticationWithPasswordSuccess
  | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  password: String
}

type RedeemUserPasswordResetTokenResult {
  code: PasswordResetRedemptionErrorCode!
  message: String!
}

enum PasswordResetRedemptionErrorCode {
  FAILURE
  TOKEN_EXPIRED
  TOKEN_REDEEMED
}

union AuthenticatedItem = User

type ValidateUserPasswordResetTokenResult {
  code: PasswordResetRedemptionErrorCode!
  message: String!
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  enableSignout: Boolean!
  enableSessionItem: Boolean!
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  isOrderable: Boolean!
  isFilterable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
